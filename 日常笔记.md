#### decodeURI/encodeURI   encodeURIComponent/decodeURIComponent:
	decodeURI/encodeURI 转换不了# : /等符号,  encodeURIComponent/decodeURIComponent可以！！！
	var test1 = "http://www.w3school.com.cn/My first/";
	console.log(encodeURI(test1))  //  "http://www.w3school.com.cn/My%20first/"
	console.log(decodeURI(test1))  //  "http://www.w3school.com.cn/My first/"
	console.log(encodeURIComponent(test1))  //  "http%3A%2F%2Fwww.w3school.com.cn%2FMy%20first%2F"
	console.log(decodeURIComponent(test1))  //  "http://www.w3school.com.cn/My first/"

2.react组件名称如果第一个字符是字母，需要大写才会生效

3.特殊字符串可以使用转义符\输出

4.delete 可以删除对象的属性，可以删除数组特定位置下标元素，替换后为undefined
       不能直接删除var声明的变量，可以删除没经过var 声明的变量

	var trees = ["redwood","bay","cedar","oak","maple"];
	trees[3]=undefined;
	if (3 in trees) {
	   console.log(111)
	}
	结果会执行打印 111

	var trees = ["redwood","bay","cedar","oak","maple"];
	delete trees[3];     //用delete删除   属于下标也删除了    下面的 3 in trees 结果为false
	if (3 in trees) {
	   console.log(111)
	}
	结果不会执行打印 111

5.原生dom添加样式可以用dom.style.cssText = "color:red; font-size:13px;"
  cssText的值可以直接写成字符串~

6.

	// 初始化方法，确定组件创建时的基本流程：
    // 初始化 attrs --》 初始化 props --》 初始化 events --》 子类的初始化


  通过给组件设置attrs属性用来保存需要用到的内容，
  获取时用this.get('XXX')，设置更改属性时用this.set('xxx',xxxxx);

  beta-base/src/attribute.js中exports了initAttrs、get、set等方法
  通过this.initAttrs(config)方法初始化设置一些get set等方法，为下面调用做准备
  可读可写，发生变化时，会自动触发相关事件具体的实现过程暂时没看明白，太高级，之后深入学习

尝试熟悉使用组件倒计时，ams自己测试项目中使用，不报错，不过也没效果
发现空的span没渲染，导致出问题，在span中写上任意字符即可，
导致空的span不渲染的原因，一开始以为是iframe的原因，测试了个iframe正常渲染
结论：行内空元素貌似都不行，未知。。   原因在下面的 第 7 个

7.ams里过滤内联空标签：
	1. 页面build时并不会过滤所有空标签，仅仅会过滤掉没有任何内容的内联标签（Inline Elements）
	2. 如果确实由于特殊需求，需要保留这部分标签，正确的姿势是为其添加”data-spa-survive”属性，可以是任意值，推荐为1或true

8.   parseInt('12se')    //  12
	 parseInt('se12')    //  NaN
	 isNaN(NaN)   //  true
	 NaN == NaN   //  false
	 3e+2   // 300   表示10的平方的3倍
	 3e-2   // 0.03  表示10的-2次方的3倍

9.  reduce  // reduce两个参数 第一个是回调处理的参数   第二个是最终想要的值得初始值,不填默认是数组第一项
  	// 上例中初始为{}，   此时回调函数中a就相当于当前的返回值  最初是初始化reduce的第二个参数，这里是{}
  	// 最终 reduce第一个参数回调函数里 return 的是a  return 之前做相关a的处理就行
	var arr = [ {a:"aaa_user_xx",b:true}, {a:"bbb_admin_xx",b:true} ]
	var obj = arr.reduce(function(a,b){
		var key = 'is' + b.a.split('_')[1].charAt(0).toUpperCase() + b.a.split('_')[1].substr(1,b.a.length)
        a[key] = b.b;
        return a
	},{})
  	console.log(obj)    //  { isAdmin:true, isUser:true }

10.全局定义过变量a，函数内部重新定义变量后，再重新定义前获取时结果为undefined，并不是全局里定义的值
例：var a = 12;
	function f(){
		alert(a);
		var a = 22;
	}
	f();    //  返回undefined， 如果alert(a)之后没有定义a  此时弹出全局定义的 12;
	因为函数域始终优先于全局域，全局变量覆盖掉所有同名的全局变量了，未具体正式定义前获取即为undefined。

11. Object.keys({a:1,b:2})    // ['a','b']    // 是所有key的数组


12.浏览器特性探测

13.对象之间是引用关系，声明一个变量等于一个对象 当改变次变量的对应的值时 原对象也会改变

例： var a = { b: 1 }
     var c = a;
     c.b = 2;
     console.log(a.b)      //   2

14.     var aa = {};
		aa.toString();     //   "[object Object]"

15.  var a = [1,2,3];
	a.push(4)   ===>    a[a.length] = 4    一样的效果
	a.pop()     ===>    a.length--         一样的效果

	sort(start end)  reverse()  方法都会改变原数组
	slice(start end)  返回一个新的数组片段  不影响原数组
	splice(start end)   返回选取的片段   并且会影响原数组

16. function 对象也有一个length属性，记录该函数拥有的参数数量
	函数的caller属性，表示调用此函数的外层函数引用，在希望函数根据其调用函数做出不同的处理时，该属性显得非常有用，
	如果实在全局域里调用的此函数，此函数的caller属性值为null

	函数的toString()返回的是该函数源代码字符串，内建函数返回的是[native code]的结果

17. arguments 类似数组的对象，并非真正的数组
	arguments的callee对象是指的该参数属于的函数  
	function a(){ console.log(arguments.callee) }    //  a()

18. String
	toUpperCase()  // 转换成大写      toLowerCase() // 转换成小写
	charAt(下标) // 获取某下标的字符串         
	indexOf('xxx') //获取某字符串，可以第2个参数，是数字 代表从哪个位置开始检索

	substr(start, length)
	substring(start, end)
	slice(start, end)

19.try{
	
}catch(e){
	
}finally{
	// 最终都会执行
}

20. 当对一个对象的prototype进行完全重写时，有可能会对对象的constructor属性产生一定的负面影响，所以要做相关的修正
	function AAA(){
		this.XXX = xxx;
	}

	AAA.prototype = {
		XXX
		...
	}

	AAA.prototype.constructor = AAA  //  做修正让prototype的constructor指向自身

21.
function S(){}   //  父构造函数

function S1(){}   // 子构造函数

如果直接S1.prototype = S.prototype 来继承S的原型链，可能当定义S1的构造函数时会影响父级原型链的功能属性，
一般是用临时方法处理：
function F(){}
F.prototype = S.prototype
S1.prototype = new F();     //   从临时函数F的实例上继承父级S的原型链方法
S1.prototype.constructor = S1;  // 修正constructor

22. 深拷贝  浅拷贝
浅拷贝：
	function copy(parent){
		var c = {}
		for(var i in parent){
			c[i] = parent[i]
		}
		return c;
	}
深拷贝：
	function deepCopy(parent, c){
		var c = c || {}
		for(var i in parent){
			if(typeof parent[i] == 'object'){
				c[i] = (parent[i].constructor === Array) ? [] : {};
				deepCopy(parent[i], c[i])
			}else{
				c[i] = parent[i]
			}
		}
		return c
	}




事件：
	1.添加事件监听：addEventListener (IE: IE5开始 attachEvent，更早的用onclick)
	2.获取当前事件元素：
		function(e){
			e.target    (IE: e.srcElement)
		}
	3.停止冒泡： stopPropagation()          (IE:  cancelBubble = true )
	4.阻止默认事件：preventDefault()        (IE:  returnValue = false )
	5.移除事件监听：removeEventListener()   (IE:  datachElement()     )

	function callback(evt){
		evt = evt || window.event;
		var target = (typeof evt.target !== 'undefined') ? evt.target : evt.srcElement
	}
	if(document.addEventListener){
		document.addEventListener('click', callback, false)
	}else if(document.attachEvent){
		document.attachEvent('onclick', callback)
	}else{
		document.onclick = callback;
	}

AJAX:
	原生：
		var a = new XMLHttpRequest();
		a.onreadystatechange = function(data){
			// TODO
		};
		a.open('GET', 'URL', true);
		a.send('');


JSON:
	JSON.parse('{a:1,B:2}')  // 会报错
	JSON.parse('{"a":1,"b":2}')



构造函数是所有的属性和方法都在函数里面声明
	构造函数当成普通函数使用，相当于window调用，属性方法添加到window
	主要问题就是每个方法都要在每个实例上重新创建一遍，

原型模式：构造函数的基础上，把公用方法拿到外部的原型链对象上
	原型对象公共的对象，是构造函数的原型对象，也同时是各个实例的原型对象

Object.getPropertyOf(某个实例)  可以获取该实例的原型对象

实例创建后，重写整个原型对象，用重写之前实例调用新重写的原型对象的方法会报错

寄生构造函数： 一般是构造函数中最后存在 return 一个对象  （不建议使用）  做不到函数复用
	特点： 新建对象或者数组对象 --> 赋值以及自定义方法 --> return 这个新建的对象
	适用场景：当创建一个特殊的对象，带有一个特殊的方法的时候，不想在原型对象上改动影响别的数组
	例：创建一个特殊数组带有aaa方法
	function SpecialArray(){
		var newArr = [];
		newArr.push.apply(newArr, arguments)
		newArr.aaa = function(){
			alert(1)
		}
		return newArr
	}

	var arr = new SpecialArray(1,2,3);
	arr.aaa()


构造函数中最后存在return时
	如果return的是一个对象包括数组对象等等，new 这个构造函数产生的实例即是此return的对象
	如果return的不是对象， new的时候忽略该return


原型式继承：ES5 的 Obeject.create()属于原型式继承
	特点：和寄生有点相似，最后都有return，这里做到了原型链上的函数共享复用，运用了prototype，寄生不能函数复用
	原理：	function create(o){
				function F(){};
				F.prototype = o;
				return new F();
			}

Array.prototpe.every()   
Array.from()

var $ = require('beta-jquery/jquery2');
var Widget = require('beta-widget/widget');

var Promise = require('beta-util/es6-promise');
function ajaxData(url, options){
	return new Promise(function(resolve, reject){
		$.ajax({
			url: url,
			dataType: 'jsonp',
			data: options
		}).done(function(data){
			resolve(data);
		}).fail(function(err){
			reject(err)
		})
	})
}

// 图片懒加载
var lazyBgImg = require('/common/js/lazy-dyn-img');
lazyBgImg({
    selector : '.store-img'    //  .store-img 是需要懒加载图片的类
});


// 获取链接url中的搜索的字段值   下面是获取storelist=的值
var querySrc = require('/common/js/query-src');
var srcQuery = querySrc();
if('storelist' in srcQuery && srcQuery.storelist < navObj.find("li").length){
	navObj.find("li").eq(srcQuery.storelist).click();
}



监测原生dom加载完成触发事件  DomContentLoaded
document.addEventListerner('DomContentLoaded', function(){})
window.addEventListerner('load', function(){})    //  有缓存存在时候这个应该更快触发
1、当 onload 事件触发时，页面上所有的DOM，样式表，脚本，图片，flash都已经加载完成了。
2、当 DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片，flash

原生判断 dom 是否加载完成 document.readyState === 'complete'


松耦合
	UI层：
		1.js 与 css 分离:
			不好的写法:
				element.style.xxx = 'xxxx';
				element.style.cssText = 'xxx:xx; xxx:xx;';

			最佳：$('.xx').addClass('xxx');
		2.js 与 html 分离
			不好的写法，在dom标签上添加 onclick='xxx()'

	js层： 各个组件之间相互影响最小化



addEventListener() 函数
/*
 * 这个函数可以做到在各种浏览器中给一个元素添加事件处理程序
 * 甚至可以降级到支持给0级DOM模型对象的on属性赋值处理程序
 * （只有在非常古老的浏览器），比如Netscape4中，才会执行这一步，
 * 因此这段代码可以在所有情形下都正常工作）
 */
function addListener(target, type, handler){
    if(target.addEventListener){
        target.addEventListener(type, handler, false);
    }else if(target.attachEvent){
    		target.attachEvent("on" + type, handler);
    }else{
        target["on" + type] = handler;
    }
}


函数表达式  function () {}    // 没名字
函数声明  function xx(){}     // 有名字  xx

函数表达式调用方式：
1.自执行函数：
	(function(){}()) 或者 (function(){})()
2.用 = && || , 或者其他一元操作符也能执行，表达式后面加括号调用执行，不用再用括号包裹起来表达式
	var i = function () { return 10; } ();    // i 的值为 10
	true && function () { /* code */ } ();
	以下不推荐使用：但也能执行 表达式里面的code
		0, function () { /* code */ } ();
		!function () { /* code */ } ();
		~function () { /* code */ } ();
		-function () { /* code */ } ();
		+function () { /* code */ } ();
		new function () { /* code */ }
		new function () { /* code */ } () // 如果需要传递参数，只需要加上括弧()



null对象的this隐式执行window
	this永运不会为null或者undefined(可能这种表达方式有点儿为问题，这里指的是最终表现)，要么是引用类型的值，要么是global对象（一方面本身就是global对象，另一方面会将null隐式转换成global对象）



有哪些方法可以改变执行上下文呢？ 改变this指向
	1.通过new方法，可以将this改编成该实例化对象
	2.通过call或者apply可以改变成新的对象



HTTP协议状态码表示的意思主要分为五类,大体是:
	1××　　临时响应，代表请求已被接收，需要继续处理
	2××　　成功
	3××　　重定向
	4××　　客户端请求错误
	5××　　服务器错误


hasOwnProperty：
	for(var i in foo) {
	    if (foo.hasOwnProperty(i)) {
	        console.log(i);
	    }
	}


$.grep(arr, function(value, index){})  // 过滤


function forI (len, cb) {
	var i = 0;

	if(isNaN(len)) { return; }

	len = parseInt(len) > 0 ? len : 0;

	for( ; i< len ; i++){
		cb(i);
	}
}

forI(3, function(i){
	return 
})

对象字面量，json字符串，json对象，都是{}包裹起来的: {key: value}
	json字符串：key和value都是双引号包裹起来的
	对象字面量：key和value用单引号，或者key不用引号
区别是：
	JSON.parse处理对象字面量的时候会报错，只处理双引号包裹的json字符串，
	可以先把对象字面量用JSON.stringify() 转换成 json字符串，之后用JSON.parse处理


声明函数的length属性值：
function a(x,y,z){}
console.log(a.length)    //  3   // 会显示出函数声明时声明的参数的个数
console.log(arguments.length)    //  函数中使用arguments.length能得到实际调用函数时传入的参数个数

函数里设置arguments某个值的时候 调用时
	如果该参数没传，则获取该改动的值时为undefined，
	如果传了，不管传入什么获取的都是改动之后的值
	例：
		function t(x){
			arguments[0] = 1;
			console.log(x);
		}
		t()      // undefined
		t(5)     //  1     
		t(2)     //  1    传入什么值都只获取函数声明中更改的值


if (true) {
  var a = 1;
} else {
  var b = 2;
}
 
alert(a); // 1
alert(b); // undefined,不是b没有声明，而是b的值是undefined

虽然else里的 没有被执行到，但是b也属于已经声明的，值为undefined


全局对象的属性将与全局变量:
	
	ES6为了改变这一点，规定：var命令和function命令声明的全局变量，依旧是全局对象的属性，而let和const命令声明的全局变量，不属于全局对象的属性。也就是说，全局对象的属性将与全局变量脱钩。

	全局变量只能通过使用var关键字才能声明。
	没有var或者let const关键字声明的，不属于变量，属于全局对象的新属性，和声明的变量有区别： 例如
	a = 10;
	var b = 20;

	delete a   // true
	delete b   // false

	a      // undefined
	b      //  20


Object.prototype.toString.call({})    // "[object Object]"
Object.prototype.toString.call([])    // "[object Array]"


new Promise().then(function(data){
	return res
}).then(function(res){
	
})

alert("a" in window);
var a;

结果为弹出  true

alert(a);
var a = 1;

结果 弹出 undefined

原理：所有的变量声明都在范围作用域的顶部
	变量声明被提前了，但变量赋值没有 
		所以 "a" in window 为true 
		a赋值之前获取a的值，结果为undefined


​js对象到原始值的转换规则：
	先查看对象是否有valueOf方法，如果有并且返回的是一个

柯里化函数：

js原始值：
	ECMAScript 的原始类型之一，即 Undefined、Null、Boolean、Number 和 String 型


css3 实现制作div椭圆
	width: 300px;
	height: 500px;
	border-radius: 150px/250px;   // 长度的一半以上    加上斜杠    然后是高度的一半以上  


js处理代码流程：
	对象声明提升（包括函数，var ，这些操作，初始时都会定义到该作用域里）


setTimeout方法函数返回一个当前定时器的数字ID，方法里return数据不会被执行

// 获取对象的值，根本是获取独享指向的内存里的具体里的值
var obj = [1, 2, 3];
function f(o){
  o = [2, 3, 4];
}
f(obj);
obj   // [1, 2, 3]    
初始是[1,2,3]，后来虽然被改成[2,3,4],[2,3,4]属于新对象会新建个内存存储，obj仍然指向原来的[1,2,3]
